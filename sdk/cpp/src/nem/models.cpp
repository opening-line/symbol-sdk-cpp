#ifndef MODELS_CPP
#define MODELS_CPP

// Code generated by catbuffer cpp generator; DO NOT EDIT.

#include <vector>
#include <string>

#include "ArrayHelpers.h"
#include "BaseValue.h"
#include "ByteArray.h"

using namespace CatBuffer;
using namespace std;

class Amount : (BaseValue) {
public:
	SIZE = 8;

	void Amount(amount: int = 0) {
		super().__init__(self.SIZE, amount, Amount)
	}

	Amount deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return Amount(int.from_bytes(buffer[:8], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		return self.value.to_bytes(8, byteorder='little', signed=False)
	}

};

class Height : (BaseValue) {
public:
	SIZE = 8;

	void Height(height: int = 0) {
		super().__init__(self.SIZE, height, Height)
	}

	Height deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return Height(int.from_bytes(buffer[:8], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		return self.value.to_bytes(8, byteorder='little', signed=False)
	}

};

class Timestamp : (BaseValue) {
public:
	SIZE = 4;

	void Timestamp(timestamp: int = 0) {
		super().__init__(self.SIZE, timestamp, Timestamp)
	}

	Timestamp deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return Timestamp(int.from_bytes(buffer[:4], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		return self.value.to_bytes(4, byteorder='little', signed=False)
	}

};

class Address : (ByteArray) {
public:
	SIZE = 40;

	void Address(address: StrBytes = bytes(40)) {
		super().__init__(self.SIZE, address, Address)
	}

	size_t size() {
		return 40
	}

	Address deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return Address(ArrayHelpers.get_bytes(buffer, 40))
	}

	std::vector<uint8_t> serialize() {
		return self.bytes
	}

};

class Hash256 : (ByteArray) {
public:
	SIZE = 32;

	void Hash256(hash256: StrBytes = bytes(32)) {
		super().__init__(self.SIZE, hash256, Hash256)
	}

	size_t size() {
		return 32
	}

	Hash256 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return Hash256(ArrayHelpers.get_bytes(buffer, 32))
	}

	std::vector<uint8_t> serialize() {
		return self.bytes
	}

};

class PublicKey : (ByteArray) {
public:
	SIZE = 32;

	void PublicKey(public_key: StrBytes = bytes(32)) {
		super().__init__(self.SIZE, public_key, PublicKey)
	}

	size_t size() {
		return 32
	}

	PublicKey deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return PublicKey(ArrayHelpers.get_bytes(buffer, 32))
	}

	std::vector<uint8_t> serialize() {
		return self.bytes
	}

};

class Signature : (ByteArray) {
public:
	SIZE = 64;

	void Signature(signature: StrBytes = bytes(64)) {
		super().__init__(self.SIZE, signature, Signature)
	}

	size_t size() {
		return 64
	}

	Signature deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return Signature(ArrayHelpers.get_bytes(buffer, 64))
	}

	std::vector<uint8_t> serialize() {
		return self.bytes
	}

};

class NetworkType : (Enum) {
public:
	MAINNET = 104
	;
	TESTNET = 152
	;

	size_t size() {
		return 1
	}

	NetworkType deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return NetworkType(int.from_bytes(buffer[:1], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.value.to_bytes(1, byteorder='little', signed=False)
		return buffer
	}

	std::string to_json() {
		return self.value
	}

};

class TransactionType : (Enum) {
public:
	TRANSFER = 257
	;
	ACCOUNT_KEY_LINK = 2049
	;
	MULTISIG_ACCOUNT_MODIFICATION = 4097
	;
	MULTISIG_COSIGNATURE = 4098
	;
	MULTISIG = 4100
	;
	NAMESPACE_REGISTRATION = 8193
	;
	MOSAIC_DEFINITION = 16385
	;
	MOSAIC_SUPPLY_CHANGE = 16386
	;

	size_t size() {
		return 4
	}

	TransactionType deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return TransactionType(int.from_bytes(buffer[:4], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.value.to_bytes(4, byteorder='little', signed=False)
		return buffer
	}

	std::string to_json() {
		return self.value
	}

};

class Transaction {
public:
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp'
	}
	;

	void Transaction() {
		self._type_ = TransactionType.TRANSFER
		self._version = 0
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
	}

	void sort() {
		pass
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		return size
	}

	Transaction deserialize(const std::vector<uint8_t>& buffer) {
		size_ = len(buffer)
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		return (size_ - len(buffer), size_)
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		self._serialize(buffer)
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		return result
	}

};

class NonVerifiableTransaction {
public:
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp'
	}
	;

	void NonVerifiableTransaction() {
		self._type_ = TransactionType.TRANSFER
		self._version = 0
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
	}

	void sort() {
		pass
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		return size
	}

	NonVerifiableTransaction deserialize(const std::vector<uint8_t>& buffer) {
		size_ = len(buffer)
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		return (size_ - len(buffer), size_)
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		self._serialize(buffer)
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		return result
	}

};

class LinkAction : (Enum) {
public:
	LINK = 1
	;
	UNLINK = 2
	;

	size_t size() {
		return 4
	}

	LinkAction deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return LinkAction(int.from_bytes(buffer[:4], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.value.to_bytes(4, byteorder='little', signed=False)
		return buffer
	}

	std::string to_json() {
		return self.value
	}

};

class AccountKeyLinkTransactionV1 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.ACCOUNT_KEY_LINK;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'link_action': 'enum:LinkAction',
		'remote_public_key': 'pod:PublicKey'
	}
	;

	void AccountKeyLinkTransactionV1() {
		self._type_ = AccountKeyLinkTransactionV1.TRANSACTION_TYPE
		self._version = AccountKeyLinkTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._link_action = LinkAction.LINK
		self._remote_public_key = PublicKey()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
		self._remote_public_key_size = 32  # reserved field
	}

	void sort() {
		pass
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	LinkAction link_action() {
		return self._link_action
	}

	PublicKey remote_public_key() {
		return self._remote_public_key
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void link_action(value: LinkAction) {
		self._link_action = value
	}

	void remote_public_key(value: PublicKey) {
		self._remote_public_key = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += self.link_action.size
		size += 4
		size += self.remote_public_key.size
		return size
	}

	AccountKeyLinkTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = AccountKeyLinkTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		link_action = LinkAction.deserialize(buffer)
		buffer = buffer[link_action.size:]
		remote_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert remote_public_key_size == 32, f'Invalid value of reserved field ({remote_public_key_size})'
		remote_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[remote_public_key.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._link_action = link_action
		instance._remote_public_key = remote_public_key
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._link_action.serialize()
		buffer += self._remote_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._remote_public_key.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'link_action: {self._link_action.__str__()}, '
		result += f'remote_public_key: {self._remote_public_key.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['link_action'] = self._link_action.to_json()
		result['remote_public_key'] = self._remote_public_key.to_json()
		return result
	}

};

class NonVerifiableAccountKeyLinkTransactionV1 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.ACCOUNT_KEY_LINK;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'link_action': 'enum:LinkAction',
		'remote_public_key': 'pod:PublicKey'
	}
	;

	void NonVerifiableAccountKeyLinkTransactionV1() {
		self._type_ = NonVerifiableAccountKeyLinkTransactionV1.TRANSACTION_TYPE
		self._version = NonVerifiableAccountKeyLinkTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._link_action = LinkAction.LINK
		self._remote_public_key = PublicKey()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._remote_public_key_size = 32  # reserved field
	}

	void sort() {
		pass
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	LinkAction link_action() {
		return self._link_action
	}

	PublicKey remote_public_key() {
		return self._remote_public_key
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void link_action(value: LinkAction) {
		self._link_action = value
	}

	void remote_public_key(value: PublicKey) {
		self._remote_public_key = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += self.link_action.size
		size += 4
		size += self.remote_public_key.size
		return size
	}

	NonVerifiableAccountKeyLinkTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableAccountKeyLinkTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		link_action = LinkAction.deserialize(buffer)
		buffer = buffer[link_action.size:]
		remote_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert remote_public_key_size == 32, f'Invalid value of reserved field ({remote_public_key_size})'
		remote_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[remote_public_key.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._link_action = link_action
		instance._remote_public_key = remote_public_key
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._link_action.serialize()
		buffer += self._remote_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._remote_public_key.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'link_action: {self._link_action.__str__()}, '
		result += f'remote_public_key: {self._remote_public_key.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['link_action'] = self._link_action.to_json()
		result['remote_public_key'] = self._remote_public_key.to_json()
		return result
	}

};

class NamespaceId {
public:
	TYPE_HINTS = {
		'name': 'bytes_array'
	}
	;

	void NamespaceId() {
		self._name = bytes()
	}

	void sort() {
		pass
	}

	bytes name() {
		return self._name
	}

	void name(value: bytes) {
		self._name = value
	}

	size_t size() {
		size = 0
		size += 4
		size += len(self._name)
		return size
	}

	NamespaceId deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NamespaceId()
		name_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		name = ArrayHelpers.get_bytes(buffer, name_size)
		buffer = buffer[name_size:]

		# pylint: disable=protected-access
		instance._name = name
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += len(self._name).to_bytes(4, byteorder='little', signed=False)  # name_size
		buffer += self._name
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'name: {hexlify(self._name).decode("utf8")}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['name'] = hexlify(self._name).decode('utf8')
		return result
	}

};

class MosaicId {
public:
	TYPE_HINTS = {
		'namespace_id': 'struct:NamespaceId',
		'name': 'bytes_array'
	}
	;

	void MosaicId() {
		self._namespace_id = NamespaceId()
		self._name = bytes()
	}

	void sort() {
		self._namespace_id.sort()
	}

	NamespaceId namespace_id() {
		return self._namespace_id
	}

	bytes name() {
		return self._name
	}

	void namespace_id(value: NamespaceId) {
		self._namespace_id = value
	}

	void name(value: bytes) {
		self._name = value
	}

	size_t size() {
		size = 0
		size += self.namespace_id.size
		size += 4
		size += len(self._name)
		return size
	}

	MosaicId deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MosaicId()
		namespace_id = NamespaceId.deserialize(buffer)
		buffer = buffer[namespace_id.size:]
		name_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		name = ArrayHelpers.get_bytes(buffer, name_size)
		buffer = buffer[name_size:]

		# pylint: disable=protected-access
		instance._namespace_id = namespace_id
		instance._name = name
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._namespace_id.serialize()
		buffer += len(self._name).to_bytes(4, byteorder='little', signed=False)  # name_size
		buffer += self._name
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'namespace_id: {self._namespace_id.__str__()}, '
		result += f'name: {hexlify(self._name).decode("utf8")}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['namespace_id'] = self._namespace_id.to_json()
		result['name'] = hexlify(self._name).decode('utf8')
		return result
	}

};

class Mosaic {
public:
	TYPE_HINTS = {
		'mosaic_id': 'struct:MosaicId',
		'amount': 'pod:Amount'
	}
	;

	void Mosaic() {
		self._mosaic_id = MosaicId()
		self._amount = Amount()
	}

	void sort() {
		self._mosaic_id.sort()
	}

	MosaicId mosaic_id() {
		return self._mosaic_id
	}

	Amount amount() {
		return self._amount
	}

	void mosaic_id(value: MosaicId) {
		self._mosaic_id = value
	}

	void amount(value: Amount) {
		self._amount = value
	}

	size_t size() {
		size = 0
		size += 4
		size += self.mosaic_id.size
		size += self.amount.size
		return size
	}

	Mosaic deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = Mosaic()
		mosaic_id_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		mosaic_id = MosaicId.deserialize(buffer[:mosaic_id_size])
		buffer = buffer[mosaic_id.size:]
		amount = Amount.deserialize(buffer)
		buffer = buffer[amount.size:]

		# pylint: disable=protected-access
		instance._mosaic_id = mosaic_id
		instance._amount = amount
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.mosaic_id.size.to_bytes(4, byteorder='little', signed=False)  # mosaic_id_size
		buffer += self._mosaic_id.serialize()
		buffer += self._amount.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'mosaic_id: {self._mosaic_id.__str__()}, '
		result += f'amount: {self._amount.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['mosaic_id'] = self._mosaic_id.to_json()
		result['amount'] = self._amount.to_json()
		return result
	}

};

class SizePrefixedMosaic {
public:
	TYPE_HINTS = {
		'mosaic': 'struct:Mosaic'
	}
	;

	void SizePrefixedMosaic() {
		self._mosaic = Mosaic()
	}

	void sort() {
		self._mosaic.sort()
	}

	Mosaic mosaic() {
		return self._mosaic
	}

	void mosaic(value: Mosaic) {
		self._mosaic = value
	}

	size_t size() {
		size = 0
		size += 4
		size += self.mosaic.size
		return size
	}

	SizePrefixedMosaic deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = SizePrefixedMosaic()
		mosaic_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		mosaic = Mosaic.deserialize(buffer[:mosaic_size])
		buffer = buffer[mosaic.size:]

		# pylint: disable=protected-access
		instance._mosaic = mosaic
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.mosaic.size.to_bytes(4, byteorder='little', signed=False)  # mosaic_size
		buffer += self._mosaic.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'mosaic: {self._mosaic.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['mosaic'] = self._mosaic.to_json()
		return result
	}

};

class MosaicTransferFeeType : (Enum) {
public:
	ABSOLUTE = 1
	;
	PERCENTILE = 2
	;

	size_t size() {
		return 4
	}

	MosaicTransferFeeType deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return MosaicTransferFeeType(int.from_bytes(buffer[:4], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.value.to_bytes(4, byteorder='little', signed=False)
		return buffer
	}

	std::string to_json() {
		return self.value
	}

};

class MosaicLevy {
public:
	TYPE_HINTS = {
		'transfer_fee_type': 'enum:MosaicTransferFeeType',
		'recipient_address': 'pod:Address',
		'mosaic_id': 'struct:MosaicId',
		'fee': 'pod:Amount'
	}
	;

	void MosaicLevy() {
		self._transfer_fee_type = MosaicTransferFeeType.ABSOLUTE
		self._recipient_address = Address()
		self._mosaic_id = MosaicId()
		self._fee = Amount()
		self._recipient_address_size = 40  # reserved field
	}

	void sort() {
		self._mosaic_id.sort()
	}

	MosaicTransferFeeType transfer_fee_type() {
		return self._transfer_fee_type
	}

	Address recipient_address() {
		return self._recipient_address
	}

	MosaicId mosaic_id() {
		return self._mosaic_id
	}

	Amount fee() {
		return self._fee
	}

	void transfer_fee_type(value: MosaicTransferFeeType) {
		self._transfer_fee_type = value
	}

	void recipient_address(value: Address) {
		self._recipient_address = value
	}

	void mosaic_id(value: MosaicId) {
		self._mosaic_id = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	size_t size() {
		size = 0
		size += self.transfer_fee_type.size
		size += 4
		size += self.recipient_address.size
		size += 4
		size += self.mosaic_id.size
		size += self.fee.size
		return size
	}

	MosaicLevy deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MosaicLevy()
		transfer_fee_type = MosaicTransferFeeType.deserialize(buffer)
		buffer = buffer[transfer_fee_type.size:]
		recipient_address_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert recipient_address_size == 40, f'Invalid value of reserved field ({recipient_address_size})'
		recipient_address = Address.deserialize(buffer)
		buffer = buffer[recipient_address.size:]
		mosaic_id_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		mosaic_id = MosaicId.deserialize(buffer[:mosaic_id_size])
		buffer = buffer[mosaic_id.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]

		# pylint: disable=protected-access
		instance._transfer_fee_type = transfer_fee_type
		instance._recipient_address = recipient_address
		instance._mosaic_id = mosaic_id
		instance._fee = fee
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._transfer_fee_type.serialize()
		buffer += self._recipient_address_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._recipient_address.serialize()
		buffer += self.mosaic_id.size.to_bytes(4, byteorder='little', signed=False)  # mosaic_id_size
		buffer += self._mosaic_id.serialize()
		buffer += self._fee.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'transfer_fee_type: {self._transfer_fee_type.__str__()}, '
		result += f'recipient_address: {self._recipient_address.__str__()}, '
		result += f'mosaic_id: {self._mosaic_id.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['transfer_fee_type'] = self._transfer_fee_type.to_json()
		result['recipient_address'] = self._recipient_address.to_json()
		result['mosaic_id'] = self._mosaic_id.to_json()
		result['fee'] = self._fee.to_json()
		return result
	}

};

class MosaicProperty {
public:
	TYPE_HINTS = {
		'name': 'bytes_array',
		'value': 'bytes_array'
	}
	;

	void MosaicProperty() {
		self._name = bytes()
		self._value = bytes()
	}

	void sort() {
		pass
	}

	bytes name() {
		return self._name
	}

	bytes value() {
		return self._value
	}

	void name(value: bytes) {
		self._name = value
	}

	void value(value: bytes) {
		self._value = value
	}

	size_t size() {
		size = 0
		size += 4
		size += len(self._name)
		size += 4
		size += len(self._value)
		return size
	}

	MosaicProperty deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MosaicProperty()
		name_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		name = ArrayHelpers.get_bytes(buffer, name_size)
		buffer = buffer[name_size:]
		value_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		value = ArrayHelpers.get_bytes(buffer, value_size)
		buffer = buffer[value_size:]

		# pylint: disable=protected-access
		instance._name = name
		instance._value = value
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += len(self._name).to_bytes(4, byteorder='little', signed=False)  # name_size
		buffer += self._name
		buffer += len(self._value).to_bytes(4, byteorder='little', signed=False)  # value_size
		buffer += self._value
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'name: {hexlify(self._name).decode("utf8")}, '
		result += f'value: {hexlify(self._value).decode("utf8")}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['name'] = hexlify(self._name).decode('utf8')
		result['value'] = hexlify(self._value).decode('utf8')
		return result
	}

};

class SizePrefixedMosaicProperty {
public:
	TYPE_HINTS = {
		'property_': 'struct:MosaicProperty'
	}
	;

	void SizePrefixedMosaicProperty() {
		self._property_ = MosaicProperty()
	}

	void sort() {
		self._property_.sort()
	}

	MosaicProperty property_() {
		return self._property_
	}

	void property_(value: MosaicProperty) {
		self._property_ = value
	}

	size_t size() {
		size = 0
		size += 4
		size += self.property_.size
		return size
	}

	SizePrefixedMosaicProperty deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = SizePrefixedMosaicProperty()
		property_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		property_ = MosaicProperty.deserialize(buffer[:property_size])
		buffer = buffer[property_.size:]

		# pylint: disable=protected-access
		instance._property_ = property_
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.property_.size.to_bytes(4, byteorder='little', signed=False)  # property_size
		buffer += self._property_.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'property: {self._property_.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['property'] = self._property_.to_json()
		return result
	}

};

class MosaicDefinition {
public:
	TYPE_HINTS = {
		'owner_public_key': 'pod:PublicKey',
		'id': 'struct:MosaicId',
		'description': 'bytes_array',
		'properties': 'array[SizePrefixedMosaicProperty]',
		'levy': 'struct:MosaicLevy'
	}
	;

	void MosaicDefinition() {
		self._owner_public_key = PublicKey()
		self._id = MosaicId()
		self._description = bytes()
		self._properties = []
		self._levy = None
		self._owner_public_key_size = 32  # reserved field
	}

	void sort() {
		self._id.sort()
		if 0 != self.levy_size_computed:
			self._levy.sort()
	}

	PublicKey owner_public_key() {
		return self._owner_public_key
	}

	MosaicId id() {
		return self._id
	}

	bytes description() {
		return self._description
	}

	List[SizePrefixedMosaicProperty] properties() {
		return self._properties
	}

	MosaicLevy levy() {
		return self._levy
	}

	int levy_size_computed() {
		return 0 if not self.levy else self.levy.size + 0
	}

	void owner_public_key(value: PublicKey) {
		self._owner_public_key = value
	}

	void id(value: MosaicId) {
		self._id = value
	}

	void description(value: bytes) {
		self._description = value
	}

	void properties(value: List[SizePrefixedMosaicProperty]) {
		self._properties = value
	}

	void levy(value: MosaicLevy) {
		self._levy = value
	}

	size_t size() {
		size = 0
		size += 4
		size += self.owner_public_key.size
		size += 4
		size += self.id.size
		size += 4
		size += len(self._description)
		size += 4
		size += ArrayHelpers.size(self.properties)
		size += 4
		if 0 != self.levy_size_computed:
			size += self.levy.size
		return size
	}

	MosaicDefinition deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MosaicDefinition()
		owner_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert owner_public_key_size == 32, f'Invalid value of reserved field ({owner_public_key_size})'
		owner_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[owner_public_key.size:]
		id_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		id = MosaicId.deserialize(buffer[:id_size])
		buffer = buffer[id.size:]
		description_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		description = ArrayHelpers.get_bytes(buffer, description_size)
		buffer = buffer[description_size:]
		properties_count = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		properties = ArrayHelpers.read_array_count(buffer, SizePrefixedMosaicProperty, properties_count)
		buffer = buffer[ArrayHelpers.size(properties):]
		levy_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		levy = None
		if 0 != levy_size:
			levy = MosaicLevy.deserialize(buffer)
			buffer = buffer[levy.size:]

		# pylint: disable=protected-access
		instance._owner_public_key = owner_public_key
		instance._id = id
		instance._description = description
		instance._properties = properties
		instance._levy = levy
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._owner_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._owner_public_key.serialize()
		buffer += self.id.size.to_bytes(4, byteorder='little', signed=False)  # id_size
		buffer += self._id.serialize()
		buffer += len(self._description).to_bytes(4, byteorder='little', signed=False)  # description_size
		buffer += self._description
		buffer += len(self._properties).to_bytes(4, byteorder='little', signed=False)  # properties_count
		buffer += ArrayHelpers.write_array(self._properties)
		buffer += self.levy_size_computed.to_bytes(4, byteorder='little', signed=False)
		if 0 != self.levy_size_computed:
			buffer += self._levy.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'owner_public_key: {self._owner_public_key.__str__()}, '
		result += f'id: {self._id.__str__()}, '
		result += f'description: {hexlify(self._description).decode("utf8")}, '
		result += f'properties: {list(map(str, self._properties))}, '
		if 0 != self.levy_size_computed:
			result += f'levy: {self._levy.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['owner_public_key'] = self._owner_public_key.to_json()
		result['id'] = self._id.to_json()
		result['description'] = hexlify(self._description).decode('utf8')
		result['properties'] = [e.to_json() for e in self._properties]
		if 0 != self.levy_size_computed:
			result['levy'] = self._levy.to_json()
		return result
	}

};

class MosaicDefinitionTransactionV1 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MOSAIC_DEFINITION;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'mosaic_definition': 'struct:MosaicDefinition',
		'rental_fee_sink': 'pod:Address',
		'rental_fee': 'pod:Amount'
	}
	;

	void MosaicDefinitionTransactionV1() {
		self._type_ = MosaicDefinitionTransactionV1.TRANSACTION_TYPE
		self._version = MosaicDefinitionTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._mosaic_definition = MosaicDefinition()
		self._rental_fee_sink = Address()
		self._rental_fee = Amount()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
		self._rental_fee_sink_size = 40  # reserved field
	}

	void sort() {
		self._mosaic_definition.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	MosaicDefinition mosaic_definition() {
		return self._mosaic_definition
	}

	Address rental_fee_sink() {
		return self._rental_fee_sink
	}

	Amount rental_fee() {
		return self._rental_fee
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void mosaic_definition(value: MosaicDefinition) {
		self._mosaic_definition = value
	}

	void rental_fee_sink(value: Address) {
		self._rental_fee_sink = value
	}

	void rental_fee(value: Amount) {
		self._rental_fee = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.mosaic_definition.size
		size += 4
		size += self.rental_fee_sink.size
		size += self.rental_fee.size
		return size
	}

	MosaicDefinitionTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MosaicDefinitionTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		mosaic_definition_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		mosaic_definition = MosaicDefinition.deserialize(buffer[:mosaic_definition_size])
		buffer = buffer[mosaic_definition.size:]
		rental_fee_sink_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert rental_fee_sink_size == 40, f'Invalid value of reserved field ({rental_fee_sink_size})'
		rental_fee_sink = Address.deserialize(buffer)
		buffer = buffer[rental_fee_sink.size:]
		rental_fee = Amount.deserialize(buffer)
		buffer = buffer[rental_fee.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._mosaic_definition = mosaic_definition
		instance._rental_fee_sink = rental_fee_sink
		instance._rental_fee = rental_fee
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self.mosaic_definition.size.to_bytes(4, byteorder='little', signed=False)  # mosaic_definition_size
		buffer += self._mosaic_definition.serialize()
		buffer += self._rental_fee_sink_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._rental_fee_sink.serialize()
		buffer += self._rental_fee.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'mosaic_definition: {self._mosaic_definition.__str__()}, '
		result += f'rental_fee_sink: {self._rental_fee_sink.__str__()}, '
		result += f'rental_fee: {self._rental_fee.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['mosaic_definition'] = self._mosaic_definition.to_json()
		result['rental_fee_sink'] = self._rental_fee_sink.to_json()
		result['rental_fee'] = self._rental_fee.to_json()
		return result
	}

};

class NonVerifiableMosaicDefinitionTransactionV1 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MOSAIC_DEFINITION;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'mosaic_definition': 'struct:MosaicDefinition',
		'rental_fee_sink': 'pod:Address',
		'rental_fee': 'pod:Amount'
	}
	;

	void NonVerifiableMosaicDefinitionTransactionV1() {
		self._type_ = NonVerifiableMosaicDefinitionTransactionV1.TRANSACTION_TYPE
		self._version = NonVerifiableMosaicDefinitionTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._mosaic_definition = MosaicDefinition()
		self._rental_fee_sink = Address()
		self._rental_fee = Amount()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._rental_fee_sink_size = 40  # reserved field
	}

	void sort() {
		self._mosaic_definition.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	MosaicDefinition mosaic_definition() {
		return self._mosaic_definition
	}

	Address rental_fee_sink() {
		return self._rental_fee_sink
	}

	Amount rental_fee() {
		return self._rental_fee
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void mosaic_definition(value: MosaicDefinition) {
		self._mosaic_definition = value
	}

	void rental_fee_sink(value: Address) {
		self._rental_fee_sink = value
	}

	void rental_fee(value: Amount) {
		self._rental_fee = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.mosaic_definition.size
		size += 4
		size += self.rental_fee_sink.size
		size += self.rental_fee.size
		return size
	}

	NonVerifiableMosaicDefinitionTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableMosaicDefinitionTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		mosaic_definition_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		mosaic_definition = MosaicDefinition.deserialize(buffer[:mosaic_definition_size])
		buffer = buffer[mosaic_definition.size:]
		rental_fee_sink_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert rental_fee_sink_size == 40, f'Invalid value of reserved field ({rental_fee_sink_size})'
		rental_fee_sink = Address.deserialize(buffer)
		buffer = buffer[rental_fee_sink.size:]
		rental_fee = Amount.deserialize(buffer)
		buffer = buffer[rental_fee.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._mosaic_definition = mosaic_definition
		instance._rental_fee_sink = rental_fee_sink
		instance._rental_fee = rental_fee
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self.mosaic_definition.size.to_bytes(4, byteorder='little', signed=False)  # mosaic_definition_size
		buffer += self._mosaic_definition.serialize()
		buffer += self._rental_fee_sink_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._rental_fee_sink.serialize()
		buffer += self._rental_fee.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'mosaic_definition: {self._mosaic_definition.__str__()}, '
		result += f'rental_fee_sink: {self._rental_fee_sink.__str__()}, '
		result += f'rental_fee: {self._rental_fee.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['mosaic_definition'] = self._mosaic_definition.to_json()
		result['rental_fee_sink'] = self._rental_fee_sink.to_json()
		result['rental_fee'] = self._rental_fee.to_json()
		return result
	}

};

class MosaicSupplyChangeAction : (Enum) {
public:
	INCREASE = 1
	;
	DECREASE = 2
	;

	size_t size() {
		return 4
	}

	MosaicSupplyChangeAction deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return MosaicSupplyChangeAction(int.from_bytes(buffer[:4], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.value.to_bytes(4, byteorder='little', signed=False)
		return buffer
	}

	std::string to_json() {
		return self.value
	}

};

class MosaicSupplyChangeTransactionV1 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MOSAIC_SUPPLY_CHANGE;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'mosaic_id': 'struct:MosaicId',
		'action': 'enum:MosaicSupplyChangeAction',
		'delta': 'pod:Amount'
	}
	;

	void MosaicSupplyChangeTransactionV1() {
		self._type_ = MosaicSupplyChangeTransactionV1.TRANSACTION_TYPE
		self._version = MosaicSupplyChangeTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._mosaic_id = MosaicId()
		self._action = MosaicSupplyChangeAction.INCREASE
		self._delta = Amount()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
	}

	void sort() {
		self._mosaic_id.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	MosaicId mosaic_id() {
		return self._mosaic_id
	}

	MosaicSupplyChangeAction action() {
		return self._action
	}

	Amount delta() {
		return self._delta
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void mosaic_id(value: MosaicId) {
		self._mosaic_id = value
	}

	void action(value: MosaicSupplyChangeAction) {
		self._action = value
	}

	void delta(value: Amount) {
		self._delta = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.mosaic_id.size
		size += self.action.size
		size += self.delta.size
		return size
	}

	MosaicSupplyChangeTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MosaicSupplyChangeTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		mosaic_id_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		mosaic_id = MosaicId.deserialize(buffer[:mosaic_id_size])
		buffer = buffer[mosaic_id.size:]
		action = MosaicSupplyChangeAction.deserialize(buffer)
		buffer = buffer[action.size:]
		delta = Amount.deserialize(buffer)
		buffer = buffer[delta.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._mosaic_id = mosaic_id
		instance._action = action
		instance._delta = delta
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self.mosaic_id.size.to_bytes(4, byteorder='little', signed=False)  # mosaic_id_size
		buffer += self._mosaic_id.serialize()
		buffer += self._action.serialize()
		buffer += self._delta.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'mosaic_id: {self._mosaic_id.__str__()}, '
		result += f'action: {self._action.__str__()}, '
		result += f'delta: {self._delta.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['mosaic_id'] = self._mosaic_id.to_json()
		result['action'] = self._action.to_json()
		result['delta'] = self._delta.to_json()
		return result
	}

};

class NonVerifiableMosaicSupplyChangeTransactionV1 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MOSAIC_SUPPLY_CHANGE;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'mosaic_id': 'struct:MosaicId',
		'action': 'enum:MosaicSupplyChangeAction',
		'delta': 'pod:Amount'
	}
	;

	void NonVerifiableMosaicSupplyChangeTransactionV1() {
		self._type_ = NonVerifiableMosaicSupplyChangeTransactionV1.TRANSACTION_TYPE
		self._version = NonVerifiableMosaicSupplyChangeTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._mosaic_id = MosaicId()
		self._action = MosaicSupplyChangeAction.INCREASE
		self._delta = Amount()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
	}

	void sort() {
		self._mosaic_id.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	MosaicId mosaic_id() {
		return self._mosaic_id
	}

	MosaicSupplyChangeAction action() {
		return self._action
	}

	Amount delta() {
		return self._delta
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void mosaic_id(value: MosaicId) {
		self._mosaic_id = value
	}

	void action(value: MosaicSupplyChangeAction) {
		self._action = value
	}

	void delta(value: Amount) {
		self._delta = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.mosaic_id.size
		size += self.action.size
		size += self.delta.size
		return size
	}

	NonVerifiableMosaicSupplyChangeTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableMosaicSupplyChangeTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		mosaic_id_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		mosaic_id = MosaicId.deserialize(buffer[:mosaic_id_size])
		buffer = buffer[mosaic_id.size:]
		action = MosaicSupplyChangeAction.deserialize(buffer)
		buffer = buffer[action.size:]
		delta = Amount.deserialize(buffer)
		buffer = buffer[delta.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._mosaic_id = mosaic_id
		instance._action = action
		instance._delta = delta
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self.mosaic_id.size.to_bytes(4, byteorder='little', signed=False)  # mosaic_id_size
		buffer += self._mosaic_id.serialize()
		buffer += self._action.serialize()
		buffer += self._delta.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'mosaic_id: {self._mosaic_id.__str__()}, '
		result += f'action: {self._action.__str__()}, '
		result += f'delta: {self._delta.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['mosaic_id'] = self._mosaic_id.to_json()
		result['action'] = self._action.to_json()
		result['delta'] = self._delta.to_json()
		return result
	}

};

class MultisigAccountModificationType : (Enum) {
public:
	ADD_COSIGNATORY = 1
	;
	DELETE_COSIGNATORY = 2
	;

	size_t size() {
		return 4
	}

	MultisigAccountModificationType deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return MultisigAccountModificationType(int.from_bytes(buffer[:4], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.value.to_bytes(4, byteorder='little', signed=False)
		return buffer
	}

	std::string to_json() {
		return self.value
	}

};

class MultisigAccountModification {
public:
	TYPE_HINTS = {
		'modification_type': 'enum:MultisigAccountModificationType',
		'cosignatory_public_key': 'pod:PublicKey'
	}
	;

	void MultisigAccountModification() {
		self._modification_type = MultisigAccountModificationType.ADD_COSIGNATORY
		self._cosignatory_public_key = PublicKey()
		self._cosignatory_public_key_size = 32  # reserved field
	}

	void comparer() {
		from ..Transforms import ripemd_keccak_256  # pylint: disable=import-outside-toplevel

		return (
			self.modification_type if not isinstance(self.modification_type, Enum) else self.modification_type.value,
			ripemd_keccak_256(self.cosignatory_public_key.bytes),
		)
	}

	void sort() {
		pass
	}

	MultisigAccountModificationType modification_type() {
		return self._modification_type
	}

	PublicKey cosignatory_public_key() {
		return self._cosignatory_public_key
	}

	void modification_type(value: MultisigAccountModificationType) {
		self._modification_type = value
	}

	void cosignatory_public_key(value: PublicKey) {
		self._cosignatory_public_key = value
	}

	size_t size() {
		size = 0
		size += self.modification_type.size
		size += 4
		size += self.cosignatory_public_key.size
		return size
	}

	MultisigAccountModification deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MultisigAccountModification()
		modification_type = MultisigAccountModificationType.deserialize(buffer)
		buffer = buffer[modification_type.size:]
		cosignatory_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert cosignatory_public_key_size == 32, f'Invalid value of reserved field ({cosignatory_public_key_size})'
		cosignatory_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[cosignatory_public_key.size:]

		# pylint: disable=protected-access
		instance._modification_type = modification_type
		instance._cosignatory_public_key = cosignatory_public_key
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._modification_type.serialize()
		buffer += self._cosignatory_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._cosignatory_public_key.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'modification_type: {self._modification_type.__str__()}, '
		result += f'cosignatory_public_key: {self._cosignatory_public_key.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['modification_type'] = self._modification_type.to_json()
		result['cosignatory_public_key'] = self._cosignatory_public_key.to_json()
		return result
	}

};

class SizePrefixedMultisigAccountModification {
public:
	TYPE_HINTS = {
		'modification': 'struct:MultisigAccountModification'
	}
	;

	void SizePrefixedMultisigAccountModification() {
		self._modification = MultisigAccountModification()
	}

	void sort() {
		self._modification.sort()
	}

	MultisigAccountModification modification() {
		return self._modification
	}

	void modification(value: MultisigAccountModification) {
		self._modification = value
	}

	size_t size() {
		size = 0
		size += 4
		size += self.modification.size
		return size
	}

	SizePrefixedMultisigAccountModification deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = SizePrefixedMultisigAccountModification()
		modification_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		modification = MultisigAccountModification.deserialize(buffer[:modification_size])
		buffer = buffer[modification.size:]

		# pylint: disable=protected-access
		instance._modification = modification
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.modification.size.to_bytes(4, byteorder='little', signed=False)  # modification_size
		buffer += self._modification.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'modification: {self._modification.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['modification'] = self._modification.to_json()
		return result
	}

};

class MultisigAccountModificationTransactionV1 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MULTISIG_ACCOUNT_MODIFICATION;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'modifications': 'array[SizePrefixedMultisigAccountModification]'
	}
	;

	void MultisigAccountModificationTransactionV1() {
		self._type_ = MultisigAccountModificationTransactionV1.TRANSACTION_TYPE
		self._version = MultisigAccountModificationTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._modifications = []
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
	}

	void sort() {
		self._modifications = sorted(self._modifications, key=lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	List[SizePrefixedMultisigAccountModification] modifications() {
		return self._modifications
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void modifications(value: List[SizePrefixedMultisigAccountModification]) {
		self._modifications = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += ArrayHelpers.size(self.modifications)
		return size
	}

	MultisigAccountModificationTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MultisigAccountModificationTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		modifications_count = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		modifications = ArrayHelpers.read_array_count(buffer, SizePrefixedMultisigAccountModification, modifications_count, lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
		buffer = buffer[ArrayHelpers.size(modifications):]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._modifications = modifications
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += len(self._modifications).to_bytes(4, byteorder='little', signed=False)  # modifications_count
		buffer += ArrayHelpers.write_array(self._modifications, lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'modifications: {list(map(str, self._modifications))}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['modifications'] = [e.to_json() for e in self._modifications]
		return result
	}

};

class NonVerifiableMultisigAccountModificationTransactionV1 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MULTISIG_ACCOUNT_MODIFICATION;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'modifications': 'array[SizePrefixedMultisigAccountModification]'
	}
	;

	void NonVerifiableMultisigAccountModificationTransactionV1() {
		self._type_ = NonVerifiableMultisigAccountModificationTransactionV1.TRANSACTION_TYPE
		self._version = NonVerifiableMultisigAccountModificationTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._modifications = []
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
	}

	void sort() {
		self._modifications = sorted(self._modifications, key=lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	List[SizePrefixedMultisigAccountModification] modifications() {
		return self._modifications
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void modifications(value: List[SizePrefixedMultisigAccountModification]) {
		self._modifications = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += ArrayHelpers.size(self.modifications)
		return size
	}

	NonVerifiableMultisigAccountModificationTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableMultisigAccountModificationTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		modifications_count = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		modifications = ArrayHelpers.read_array_count(buffer, SizePrefixedMultisigAccountModification, modifications_count, lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
		buffer = buffer[ArrayHelpers.size(modifications):]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._modifications = modifications
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += len(self._modifications).to_bytes(4, byteorder='little', signed=False)  # modifications_count
		buffer += ArrayHelpers.write_array(self._modifications, lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'modifications: {list(map(str, self._modifications))}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['modifications'] = [e.to_json() for e in self._modifications]
		return result
	}

};

class MultisigAccountModificationTransactionV2 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 2;
	TRANSACTION_TYPE: TransactionType = TransactionType.MULTISIG_ACCOUNT_MODIFICATION;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'modifications': 'array[SizePrefixedMultisigAccountModification]'
	}
	;

	void MultisigAccountModificationTransactionV2() {
		self._type_ = MultisigAccountModificationTransactionV2.TRANSACTION_TYPE
		self._version = MultisigAccountModificationTransactionV2.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._modifications = []
		self._min_approval_delta = 0
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
		self._min_approval_delta_size = 4  # reserved field
	}

	void sort() {
		self._modifications = sorted(self._modifications, key=lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	List[SizePrefixedMultisigAccountModification] modifications() {
		return self._modifications
	}

	int min_approval_delta() {
		return self._min_approval_delta
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void modifications(value: List[SizePrefixedMultisigAccountModification]) {
		self._modifications = value
	}

	void min_approval_delta(value: int) {
		self._min_approval_delta = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += ArrayHelpers.size(self.modifications)
		size += 4
		size += 4
		return size
	}

	MultisigAccountModificationTransactionV2 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MultisigAccountModificationTransactionV2()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		modifications_count = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		modifications = ArrayHelpers.read_array_count(buffer, SizePrefixedMultisigAccountModification, modifications_count, lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
		buffer = buffer[ArrayHelpers.size(modifications):]
		min_approval_delta_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert min_approval_delta_size == 4, f'Invalid value of reserved field ({min_approval_delta_size})'
		min_approval_delta = int.from_bytes(buffer[:4], byteorder='little', signed=True)
		buffer = buffer[4:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._modifications = modifications
		instance._min_approval_delta = min_approval_delta
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += len(self._modifications).to_bytes(4, byteorder='little', signed=False)  # modifications_count
		buffer += ArrayHelpers.write_array(self._modifications, lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
		buffer += self._min_approval_delta_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._min_approval_delta.to_bytes(4, byteorder='little', signed=True)
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'modifications: {list(map(str, self._modifications))}, '
		result += f'min_approval_delta: 0x{self._min_approval_delta:X}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['modifications'] = [e.to_json() for e in self._modifications]
		result['min_approval_delta'] = self._min_approval_delta
		return result
	}

};

class NonVerifiableMultisigAccountModificationTransactionV2 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 2;
	TRANSACTION_TYPE: TransactionType = TransactionType.MULTISIG_ACCOUNT_MODIFICATION;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'modifications': 'array[SizePrefixedMultisigAccountModification]'
	}
	;

	void NonVerifiableMultisigAccountModificationTransactionV2() {
		self._type_ = NonVerifiableMultisigAccountModificationTransactionV2.TRANSACTION_TYPE
		self._version = NonVerifiableMultisigAccountModificationTransactionV2.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._modifications = []
		self._min_approval_delta = 0
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._min_approval_delta_size = 4  # reserved field
	}

	void sort() {
		self._modifications = sorted(self._modifications, key=lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	List[SizePrefixedMultisigAccountModification] modifications() {
		return self._modifications
	}

	int min_approval_delta() {
		return self._min_approval_delta
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void modifications(value: List[SizePrefixedMultisigAccountModification]) {
		self._modifications = value
	}

	void min_approval_delta(value: int) {
		self._min_approval_delta = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += ArrayHelpers.size(self.modifications)
		size += 4
		size += 4
		return size
	}

	NonVerifiableMultisigAccountModificationTransactionV2 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableMultisigAccountModificationTransactionV2()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		modifications_count = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		modifications = ArrayHelpers.read_array_count(buffer, SizePrefixedMultisigAccountModification, modifications_count, lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
		buffer = buffer[ArrayHelpers.size(modifications):]
		min_approval_delta_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert min_approval_delta_size == 4, f'Invalid value of reserved field ({min_approval_delta_size})'
		min_approval_delta = int.from_bytes(buffer[:4], byteorder='little', signed=True)
		buffer = buffer[4:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._modifications = modifications
		instance._min_approval_delta = min_approval_delta
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += len(self._modifications).to_bytes(4, byteorder='little', signed=False)  # modifications_count
		buffer += ArrayHelpers.write_array(self._modifications, lambda e: e.modification.comparer() if hasattr(e.modification, 'comparer') else e.modification)
		buffer += self._min_approval_delta_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._min_approval_delta.to_bytes(4, byteorder='little', signed=True)
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'modifications: {list(map(str, self._modifications))}, '
		result += f'min_approval_delta: 0x{self._min_approval_delta:X}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['modifications'] = [e.to_json() for e in self._modifications]
		result['min_approval_delta'] = self._min_approval_delta
		return result
	}

};

class CosignatureV1Body {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MULTISIG_COSIGNATURE;
	TYPE_HINTS = {
		'other_transaction_hash': 'pod:Hash256',
		'multisig_account_address': 'pod:Address'
	}
	;

	void CosignatureV1Body() {
		self._other_transaction_hash = Hash256()
		self._multisig_account_address = Address()
		self._other_transaction_hash_outer_size = 36  # reserved field
		self._other_transaction_hash_size = 32  # reserved field
		self._multisig_account_address_size = 40  # reserved field
	}

	void sort() {
		pass
	}

	Hash256 other_transaction_hash() {
		return self._other_transaction_hash
	}

	Address multisig_account_address() {
		return self._multisig_account_address
	}

	void other_transaction_hash(value: Hash256) {
		self._other_transaction_hash = value
	}

	void multisig_account_address(value: Address) {
		self._multisig_account_address = value
	}

	size_t size() {
		size = 0
		size += 4
		size += 4
		size += self.other_transaction_hash.size
		size += 4
		size += self.multisig_account_address.size
		return size
	}

	CosignatureV1Body deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = CosignatureV1Body()
		other_transaction_hash_outer_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert other_transaction_hash_outer_size == 36, f'Invalid value of reserved field ({other_transaction_hash_outer_size})'
		other_transaction_hash_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert other_transaction_hash_size == 32, f'Invalid value of reserved field ({other_transaction_hash_size})'
		other_transaction_hash = Hash256.deserialize(buffer)
		buffer = buffer[other_transaction_hash.size:]
		multisig_account_address_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert multisig_account_address_size == 40, f'Invalid value of reserved field ({multisig_account_address_size})'
		multisig_account_address = Address.deserialize(buffer)
		buffer = buffer[multisig_account_address.size:]

		# pylint: disable=protected-access
		instance._other_transaction_hash = other_transaction_hash
		instance._multisig_account_address = multisig_account_address
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._other_transaction_hash_outer_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._other_transaction_hash_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._other_transaction_hash.serialize()
		buffer += self._multisig_account_address_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._multisig_account_address.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'other_transaction_hash: {self._other_transaction_hash.__str__()}, '
		result += f'multisig_account_address: {self._multisig_account_address.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['other_transaction_hash'] = self._other_transaction_hash.to_json()
		result['multisig_account_address'] = self._multisig_account_address.to_json()
		return result
	}

};

class CosignatureV1 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MULTISIG_COSIGNATURE;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'other_transaction_hash': 'pod:Hash256',
		'multisig_account_address': 'pod:Address'
	}
	;

	void CosignatureV1() {
		self._type_ = CosignatureV1.TRANSACTION_TYPE
		self._version = CosignatureV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._other_transaction_hash = Hash256()
		self._multisig_account_address = Address()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
		self._other_transaction_hash_outer_size = 36  # reserved field
		self._other_transaction_hash_size = 32  # reserved field
		self._multisig_account_address_size = 40  # reserved field
	}

	void sort() {
		pass
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	Hash256 other_transaction_hash() {
		return self._other_transaction_hash
	}

	Address multisig_account_address() {
		return self._multisig_account_address
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void other_transaction_hash(value: Hash256) {
		self._other_transaction_hash = value
	}

	void multisig_account_address(value: Address) {
		self._multisig_account_address = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += 4
		size += self.other_transaction_hash.size
		size += 4
		size += self.multisig_account_address.size
		return size
	}

	CosignatureV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = CosignatureV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		other_transaction_hash_outer_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert other_transaction_hash_outer_size == 36, f'Invalid value of reserved field ({other_transaction_hash_outer_size})'
		other_transaction_hash_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert other_transaction_hash_size == 32, f'Invalid value of reserved field ({other_transaction_hash_size})'
		other_transaction_hash = Hash256.deserialize(buffer)
		buffer = buffer[other_transaction_hash.size:]
		multisig_account_address_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert multisig_account_address_size == 40, f'Invalid value of reserved field ({multisig_account_address_size})'
		multisig_account_address = Address.deserialize(buffer)
		buffer = buffer[multisig_account_address.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._other_transaction_hash = other_transaction_hash
		instance._multisig_account_address = multisig_account_address
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._other_transaction_hash_outer_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._other_transaction_hash_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._other_transaction_hash.serialize()
		buffer += self._multisig_account_address_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._multisig_account_address.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'other_transaction_hash: {self._other_transaction_hash.__str__()}, '
		result += f'multisig_account_address: {self._multisig_account_address.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['other_transaction_hash'] = self._other_transaction_hash.to_json()
		result['multisig_account_address'] = self._multisig_account_address.to_json()
		return result
	}

};

class NonVerifiableCosignatureV1 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MULTISIG_COSIGNATURE;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'other_transaction_hash': 'pod:Hash256',
		'multisig_account_address': 'pod:Address'
	}
	;

	void NonVerifiableCosignatureV1() {
		self._type_ = NonVerifiableCosignatureV1.TRANSACTION_TYPE
		self._version = NonVerifiableCosignatureV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._other_transaction_hash = Hash256()
		self._multisig_account_address = Address()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._other_transaction_hash_outer_size = 36  # reserved field
		self._other_transaction_hash_size = 32  # reserved field
		self._multisig_account_address_size = 40  # reserved field
	}

	void sort() {
		pass
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	Hash256 other_transaction_hash() {
		return self._other_transaction_hash
	}

	Address multisig_account_address() {
		return self._multisig_account_address
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void other_transaction_hash(value: Hash256) {
		self._other_transaction_hash = value
	}

	void multisig_account_address(value: Address) {
		self._multisig_account_address = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += 4
		size += self.other_transaction_hash.size
		size += 4
		size += self.multisig_account_address.size
		return size
	}

	NonVerifiableCosignatureV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableCosignatureV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		other_transaction_hash_outer_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert other_transaction_hash_outer_size == 36, f'Invalid value of reserved field ({other_transaction_hash_outer_size})'
		other_transaction_hash_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert other_transaction_hash_size == 32, f'Invalid value of reserved field ({other_transaction_hash_size})'
		other_transaction_hash = Hash256.deserialize(buffer)
		buffer = buffer[other_transaction_hash.size:]
		multisig_account_address_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert multisig_account_address_size == 40, f'Invalid value of reserved field ({multisig_account_address_size})'
		multisig_account_address = Address.deserialize(buffer)
		buffer = buffer[multisig_account_address.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._other_transaction_hash = other_transaction_hash
		instance._multisig_account_address = multisig_account_address
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._other_transaction_hash_outer_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._other_transaction_hash_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._other_transaction_hash.serialize()
		buffer += self._multisig_account_address_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._multisig_account_address.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'other_transaction_hash: {self._other_transaction_hash.__str__()}, '
		result += f'multisig_account_address: {self._multisig_account_address.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['other_transaction_hash'] = self._other_transaction_hash.to_json()
		result['multisig_account_address'] = self._multisig_account_address.to_json()
		return result
	}

};

class SizePrefixedCosignatureV1 {
public:
	TYPE_HINTS = {
		'cosignature': 'struct:CosignatureV1'
	}
	;

	void SizePrefixedCosignatureV1() {
		self._cosignature = CosignatureV1()
	}

	void sort() {
		self._cosignature.sort()
	}

	CosignatureV1 cosignature() {
		return self._cosignature
	}

	void cosignature(value: CosignatureV1) {
		self._cosignature = value
	}

	size_t size() {
		size = 0
		size += 4
		size += self.cosignature.size
		return size
	}

	SizePrefixedCosignatureV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = SizePrefixedCosignatureV1()
		cosignature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		cosignature = CosignatureV1.deserialize(buffer[:cosignature_size])
		buffer = buffer[cosignature.size:]

		# pylint: disable=protected-access
		instance._cosignature = cosignature
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.cosignature.size.to_bytes(4, byteorder='little', signed=False)  # cosignature_size
		buffer += self._cosignature.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'cosignature: {self._cosignature.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['cosignature'] = self._cosignature.to_json()
		return result
	}

};

class MultisigTransactionV1 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MULTISIG;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'inner_transaction': 'struct:NonVerifiableTransaction',
		'cosignatures': 'array[SizePrefixedCosignatureV1]'
	}
	;

	void MultisigTransactionV1() {
		self._type_ = MultisigTransactionV1.TRANSACTION_TYPE
		self._version = MultisigTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._inner_transaction = NonVerifiableTransaction()
		self._cosignatures = []
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
	}

	void sort() {
		self._inner_transaction.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	NonVerifiableTransaction inner_transaction() {
		return self._inner_transaction
	}

	List[SizePrefixedCosignatureV1] cosignatures() {
		return self._cosignatures
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void inner_transaction(value: NonVerifiableTransaction) {
		self._inner_transaction = value
	}

	void cosignatures(value: List[SizePrefixedCosignatureV1]) {
		self._cosignatures = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.inner_transaction.size
		size += 4
		size += ArrayHelpers.size(self.cosignatures)
		return size
	}

	MultisigTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = MultisigTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		inner_transaction_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		inner_transaction = NonVerifiableTransactionFactory.deserialize(buffer[:inner_transaction_size])
		buffer = buffer[inner_transaction.size:]
		cosignatures_count = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		cosignatures = ArrayHelpers.read_array_count(buffer, SizePrefixedCosignatureV1, cosignatures_count)
		buffer = buffer[ArrayHelpers.size(cosignatures):]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._inner_transaction = inner_transaction
		instance._cosignatures = cosignatures
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self.inner_transaction.size.to_bytes(4, byteorder='little', signed=False)  # inner_transaction_size
		buffer += self._inner_transaction.serialize()
		buffer += len(self._cosignatures).to_bytes(4, byteorder='little', signed=False)  # cosignatures_count
		buffer += ArrayHelpers.write_array(self._cosignatures)
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'inner_transaction: {self._inner_transaction.__str__()}, '
		result += f'cosignatures: {list(map(str, self._cosignatures))}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['inner_transaction'] = self._inner_transaction.to_json()
		result['cosignatures'] = [e.to_json() for e in self._cosignatures]
		return result
	}

};

class NonVerifiableMultisigTransactionV1 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.MULTISIG;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'inner_transaction': 'struct:NonVerifiableTransaction'
	}
	;

	void NonVerifiableMultisigTransactionV1() {
		self._type_ = NonVerifiableMultisigTransactionV1.TRANSACTION_TYPE
		self._version = NonVerifiableMultisigTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._inner_transaction = NonVerifiableTransaction()
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
	}

	void sort() {
		self._inner_transaction.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	NonVerifiableTransaction inner_transaction() {
		return self._inner_transaction
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void inner_transaction(value: NonVerifiableTransaction) {
		self._inner_transaction = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.inner_transaction.size
		return size
	}

	NonVerifiableMultisigTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableMultisigTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		inner_transaction_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		# marking sizeof field
		inner_transaction = NonVerifiableTransactionFactory.deserialize(buffer[:inner_transaction_size])
		buffer = buffer[inner_transaction.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._inner_transaction = inner_transaction
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self.inner_transaction.size.to_bytes(4, byteorder='little', signed=False)  # inner_transaction_size
		buffer += self._inner_transaction.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'inner_transaction: {self._inner_transaction.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['inner_transaction'] = self._inner_transaction.to_json()
		return result
	}

};

class NamespaceRegistrationTransactionV1 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.NAMESPACE_REGISTRATION;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'rental_fee_sink': 'pod:Address',
		'rental_fee': 'pod:Amount',
		'name': 'bytes_array',
		'parent_name': 'bytes_array'
	}
	;

	void NamespaceRegistrationTransactionV1() {
		self._type_ = NamespaceRegistrationTransactionV1.TRANSACTION_TYPE
		self._version = NamespaceRegistrationTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._rental_fee_sink = Address()
		self._rental_fee = Amount()
		self._name = bytes()
		self._parent_name = None
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
		self._rental_fee_sink_size = 40  # reserved field
	}

	void sort() {
		pass
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	Address rental_fee_sink() {
		return self._rental_fee_sink
	}

	Amount rental_fee() {
		return self._rental_fee
	}

	bytes name() {
		return self._name
	}

	bytes parent_name() {
		return self._parent_name
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void rental_fee_sink(value: Address) {
		self._rental_fee_sink = value
	}

	void rental_fee(value: Amount) {
		self._rental_fee = value
	}

	void name(value: bytes) {
		self._name = value
	}

	void parent_name(value: bytes) {
		self._parent_name = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.rental_fee_sink.size
		size += self.rental_fee.size
		size += 4
		size += len(self._name)
		size += 4
		if self.parent_name:
			size += len(self._parent_name)
		return size
	}

	NamespaceRegistrationTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NamespaceRegistrationTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		rental_fee_sink_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert rental_fee_sink_size == 40, f'Invalid value of reserved field ({rental_fee_sink_size})'
		rental_fee_sink = Address.deserialize(buffer)
		buffer = buffer[rental_fee_sink.size:]
		rental_fee = Amount.deserialize(buffer)
		buffer = buffer[rental_fee.size:]
		name_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		name = ArrayHelpers.get_bytes(buffer, name_size)
		buffer = buffer[name_size:]
		parent_name_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		parent_name = None
		if 4294967295 != parent_name_size:
			parent_name = ArrayHelpers.get_bytes(buffer, parent_name_size)
			buffer = buffer[parent_name_size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._rental_fee_sink = rental_fee_sink
		instance._rental_fee = rental_fee
		instance._name = name
		instance._parent_name = parent_name
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._rental_fee_sink_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._rental_fee_sink.serialize()
		buffer += self._rental_fee.serialize()
		buffer += len(self._name).to_bytes(4, byteorder='little', signed=False)  # name_size
		buffer += self._name
		buffer += (len(self._parent_name) if self._parent_name is not None else 4294967295).to_bytes(4, byteorder='little', signed=False)  # parent_name_size
		if self.parent_name:
			buffer += self._parent_name
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'rental_fee_sink: {self._rental_fee_sink.__str__()}, '
		result += f'rental_fee: {self._rental_fee.__str__()}, '
		result += f'name: {hexlify(self._name).decode("utf8")}, '
		if self.parent_name:
			result += f'parent_name: {hexlify(self._parent_name).decode("utf8")}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['rental_fee_sink'] = self._rental_fee_sink.to_json()
		result['rental_fee'] = self._rental_fee.to_json()
		result['name'] = hexlify(self._name).decode('utf8')
		if self.parent_name:
			result['parent_name'] = hexlify(self._parent_name).decode('utf8')
		return result
	}

};

class NonVerifiableNamespaceRegistrationTransactionV1 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.NAMESPACE_REGISTRATION;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'rental_fee_sink': 'pod:Address',
		'rental_fee': 'pod:Amount',
		'name': 'bytes_array',
		'parent_name': 'bytes_array'
	}
	;

	void NonVerifiableNamespaceRegistrationTransactionV1() {
		self._type_ = NonVerifiableNamespaceRegistrationTransactionV1.TRANSACTION_TYPE
		self._version = NonVerifiableNamespaceRegistrationTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._rental_fee_sink = Address()
		self._rental_fee = Amount()
		self._name = bytes()
		self._parent_name = None
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._rental_fee_sink_size = 40  # reserved field
	}

	void sort() {
		pass
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	Address rental_fee_sink() {
		return self._rental_fee_sink
	}

	Amount rental_fee() {
		return self._rental_fee
	}

	bytes name() {
		return self._name
	}

	bytes parent_name() {
		return self._parent_name
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void rental_fee_sink(value: Address) {
		self._rental_fee_sink = value
	}

	void rental_fee(value: Amount) {
		self._rental_fee = value
	}

	void name(value: bytes) {
		self._name = value
	}

	void parent_name(value: bytes) {
		self._parent_name = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.rental_fee_sink.size
		size += self.rental_fee.size
		size += 4
		size += len(self._name)
		size += 4
		if self.parent_name:
			size += len(self._parent_name)
		return size
	}

	NonVerifiableNamespaceRegistrationTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableNamespaceRegistrationTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		rental_fee_sink_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert rental_fee_sink_size == 40, f'Invalid value of reserved field ({rental_fee_sink_size})'
		rental_fee_sink = Address.deserialize(buffer)
		buffer = buffer[rental_fee_sink.size:]
		rental_fee = Amount.deserialize(buffer)
		buffer = buffer[rental_fee.size:]
		name_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		name = ArrayHelpers.get_bytes(buffer, name_size)
		buffer = buffer[name_size:]
		parent_name_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		parent_name = None
		if 4294967295 != parent_name_size:
			parent_name = ArrayHelpers.get_bytes(buffer, parent_name_size)
			buffer = buffer[parent_name_size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._rental_fee_sink = rental_fee_sink
		instance._rental_fee = rental_fee
		instance._name = name
		instance._parent_name = parent_name
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._rental_fee_sink_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._rental_fee_sink.serialize()
		buffer += self._rental_fee.serialize()
		buffer += len(self._name).to_bytes(4, byteorder='little', signed=False)  # name_size
		buffer += self._name
		buffer += (len(self._parent_name) if self._parent_name is not None else 4294967295).to_bytes(4, byteorder='little', signed=False)  # parent_name_size
		if self.parent_name:
			buffer += self._parent_name
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'rental_fee_sink: {self._rental_fee_sink.__str__()}, '
		result += f'rental_fee: {self._rental_fee.__str__()}, '
		result += f'name: {hexlify(self._name).decode("utf8")}, '
		if self.parent_name:
			result += f'parent_name: {hexlify(self._parent_name).decode("utf8")}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['rental_fee_sink'] = self._rental_fee_sink.to_json()
		result['rental_fee'] = self._rental_fee.to_json()
		result['name'] = hexlify(self._name).decode('utf8')
		if self.parent_name:
			result['parent_name'] = hexlify(self._parent_name).decode('utf8')
		return result
	}

};

class MessageType : (Enum) {
public:
	PLAIN = 1
	;
	ENCRYPTED = 2
	;

	size_t size() {
		return 4
	}

	MessageType deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		return MessageType(int.from_bytes(buffer[:4], byteorder='little', signed=False))
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self.value.to_bytes(4, byteorder='little', signed=False)
		return buffer
	}

	std::string to_json() {
		return self.value
	}

};

class Message {
public:
	TYPE_HINTS = {
		'message_type': 'enum:MessageType',
		'message': 'bytes_array'
	}
	;

	void Message() {
		self._message_type = MessageType.PLAIN
		self._message = bytes()
	}

	void sort() {
		pass
	}

	MessageType message_type() {
		return self._message_type
	}

	bytes message() {
		return self._message
	}

	void message_type(value: MessageType) {
		self._message_type = value
	}

	void message(value: bytes) {
		self._message = value
	}

	size_t size() {
		size = 0
		size += self.message_type.size
		size += 4
		size += len(self._message)
		return size
	}

	Message deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = Message()
		message_type = MessageType.deserialize(buffer)
		buffer = buffer[message_type.size:]
		message_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		message = ArrayHelpers.get_bytes(buffer, message_size)
		buffer = buffer[message_size:]

		# pylint: disable=protected-access
		instance._message_type = message_type
		instance._message = message
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._message_type.serialize()
		buffer += len(self._message).to_bytes(4, byteorder='little', signed=False)  # message_size
		buffer += self._message
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'message_type: {self._message_type.__str__()}, '
		result += f'message: {hexlify(self._message).decode("utf8")}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['message_type'] = self._message_type.to_json()
		result['message'] = hexlify(self._message).decode('utf8')
		return result
	}

};

class TransferTransactionV1 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.TRANSFER;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'recipient_address': 'pod:Address',
		'amount': 'pod:Amount',
		'message': 'struct:Message'
	}
	;

	void TransferTransactionV1() {
		self._type_ = TransferTransactionV1.TRANSACTION_TYPE
		self._version = TransferTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._recipient_address = Address()
		self._amount = Amount()
		self._message = None
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
		self._recipient_address_size = 40  # reserved field
	}

	void sort() {
		if 0 != self.message_envelope_size_computed:
			self._message.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	Address recipient_address() {
		return self._recipient_address
	}

	Amount amount() {
		return self._amount
	}

	Message message() {
		return self._message
	}

	int message_envelope_size_computed() {
		return 0 if not self.message else self.message.size + 0
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void recipient_address(value: Address) {
		self._recipient_address = value
	}

	void amount(value: Amount) {
		self._amount = value
	}

	void message(value: Message) {
		self._message = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.recipient_address.size
		size += self.amount.size
		size += 4
		if 0 != self.message_envelope_size_computed:
			size += self.message.size
		return size
	}

	TransferTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = TransferTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		recipient_address_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert recipient_address_size == 40, f'Invalid value of reserved field ({recipient_address_size})'
		recipient_address = Address.deserialize(buffer)
		buffer = buffer[recipient_address.size:]
		amount = Amount.deserialize(buffer)
		buffer = buffer[amount.size:]
		message_envelope_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		message = None
		if 0 != message_envelope_size:
			message = Message.deserialize(buffer)
			buffer = buffer[message.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._recipient_address = recipient_address
		instance._amount = amount
		instance._message = message
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._recipient_address_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._recipient_address.serialize()
		buffer += self._amount.serialize()
		buffer += self.message_envelope_size_computed.to_bytes(4, byteorder='little', signed=False)
		if 0 != self.message_envelope_size_computed:
			buffer += self._message.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'recipient_address: {self._recipient_address.__str__()}, '
		result += f'amount: {self._amount.__str__()}, '
		if 0 != self.message_envelope_size_computed:
			result += f'message: {self._message.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['recipient_address'] = self._recipient_address.to_json()
		result['amount'] = self._amount.to_json()
		if 0 != self.message_envelope_size_computed:
			result['message'] = self._message.to_json()
		return result
	}

};

class NonVerifiableTransferTransactionV1 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 1;
	TRANSACTION_TYPE: TransactionType = TransactionType.TRANSFER;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'recipient_address': 'pod:Address',
		'amount': 'pod:Amount',
		'message': 'struct:Message'
	}
	;

	void NonVerifiableTransferTransactionV1() {
		self._type_ = NonVerifiableTransferTransactionV1.TRANSACTION_TYPE
		self._version = NonVerifiableTransferTransactionV1.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._recipient_address = Address()
		self._amount = Amount()
		self._message = None
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._recipient_address_size = 40  # reserved field
	}

	void sort() {
		if 0 != self.message_envelope_size_computed:
			self._message.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	Address recipient_address() {
		return self._recipient_address
	}

	Amount amount() {
		return self._amount
	}

	Message message() {
		return self._message
	}

	int message_envelope_size_computed() {
		return 0 if not self.message else self.message.size + 0
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void recipient_address(value: Address) {
		self._recipient_address = value
	}

	void amount(value: Amount) {
		self._amount = value
	}

	void message(value: Message) {
		self._message = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.recipient_address.size
		size += self.amount.size
		size += 4
		if 0 != self.message_envelope_size_computed:
			size += self.message.size
		return size
	}

	NonVerifiableTransferTransactionV1 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableTransferTransactionV1()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		recipient_address_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert recipient_address_size == 40, f'Invalid value of reserved field ({recipient_address_size})'
		recipient_address = Address.deserialize(buffer)
		buffer = buffer[recipient_address.size:]
		amount = Amount.deserialize(buffer)
		buffer = buffer[amount.size:]
		message_envelope_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		message = None
		if 0 != message_envelope_size:
			message = Message.deserialize(buffer)
			buffer = buffer[message.size:]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._recipient_address = recipient_address
		instance._amount = amount
		instance._message = message
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._recipient_address_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._recipient_address.serialize()
		buffer += self._amount.serialize()
		buffer += self.message_envelope_size_computed.to_bytes(4, byteorder='little', signed=False)
		if 0 != self.message_envelope_size_computed:
			buffer += self._message.serialize()
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'recipient_address: {self._recipient_address.__str__()}, '
		result += f'amount: {self._amount.__str__()}, '
		if 0 != self.message_envelope_size_computed:
			result += f'message: {self._message.__str__()}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['recipient_address'] = self._recipient_address.to_json()
		result['amount'] = self._amount.to_json()
		if 0 != self.message_envelope_size_computed:
			result['message'] = self._message.to_json()
		return result
	}

};

class TransferTransactionV2 : (Transaction) {
public:
	TRANSACTION_VERSION: int = 2;
	TRANSACTION_TYPE: TransactionType = TransactionType.TRANSFER;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'signature': 'pod:Signature',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'recipient_address': 'pod:Address',
		'amount': 'pod:Amount',
		'message': 'struct:Message',
		'mosaics': 'array[SizePrefixedMosaic]'
	}
	;

	void TransferTransactionV2() {
		self._type_ = TransferTransactionV2.TRANSACTION_TYPE
		self._version = TransferTransactionV2.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._signature = Signature()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._recipient_address = Address()
		self._amount = Amount()
		self._message = None
		self._mosaics = []
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._signature_size = 64  # reserved field
		self._recipient_address_size = 40  # reserved field
	}

	void sort() {
		if 0 != self.message_envelope_size_computed:
			self._message.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Signature signature() {
		return self._signature
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	Address recipient_address() {
		return self._recipient_address
	}

	Amount amount() {
		return self._amount
	}

	Message message() {
		return self._message
	}

	List[SizePrefixedMosaic] mosaics() {
		return self._mosaics
	}

	int message_envelope_size_computed() {
		return 0 if not self.message else self.message.size + 0
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void signature(value: Signature) {
		self._signature = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void recipient_address(value: Address) {
		self._recipient_address = value
	}

	void amount(value: Amount) {
		self._amount = value
	}

	void message(value: Message) {
		self._message = value
	}

	void mosaics(value: List[SizePrefixedMosaic]) {
		self._mosaics = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += 4
		size += self.signature.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.recipient_address.size
		size += self.amount.size
		size += 4
		if 0 != self.message_envelope_size_computed:
			size += self.message.size
		size += 4
		size += ArrayHelpers.size(self.mosaics)
		return size
	}

	TransferTransactionV2 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = TransferTransactionV2()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		signature_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signature_size == 64, f'Invalid value of reserved field ({signature_size})'
		signature = Signature.deserialize(buffer)
		buffer = buffer[signature.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		recipient_address_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert recipient_address_size == 40, f'Invalid value of reserved field ({recipient_address_size})'
		recipient_address = Address.deserialize(buffer)
		buffer = buffer[recipient_address.size:]
		amount = Amount.deserialize(buffer)
		buffer = buffer[amount.size:]
		message_envelope_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		message = None
		if 0 != message_envelope_size:
			message = Message.deserialize(buffer)
			buffer = buffer[message.size:]
		mosaics_count = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		mosaics = ArrayHelpers.read_array_count(buffer, SizePrefixedMosaic, mosaics_count)
		buffer = buffer[ArrayHelpers.size(mosaics):]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._signature = signature
		instance._fee = fee
		instance._deadline = deadline
		instance._recipient_address = recipient_address
		instance._amount = amount
		instance._message = message
		instance._mosaics = mosaics
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._signature_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signature.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._recipient_address_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._recipient_address.serialize()
		buffer += self._amount.serialize()
		buffer += self.message_envelope_size_computed.to_bytes(4, byteorder='little', signed=False)
		if 0 != self.message_envelope_size_computed:
			buffer += self._message.serialize()
		buffer += len(self._mosaics).to_bytes(4, byteorder='little', signed=False)  # mosaics_count
		buffer += ArrayHelpers.write_array(self._mosaics)
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'signature: {self._signature.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'recipient_address: {self._recipient_address.__str__()}, '
		result += f'amount: {self._amount.__str__()}, '
		if 0 != self.message_envelope_size_computed:
			result += f'message: {self._message.__str__()}, '
		result += f'mosaics: {list(map(str, self._mosaics))}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['signature'] = self._signature.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['recipient_address'] = self._recipient_address.to_json()
		result['amount'] = self._amount.to_json()
		if 0 != self.message_envelope_size_computed:
			result['message'] = self._message.to_json()
		result['mosaics'] = [e.to_json() for e in self._mosaics]
		return result
	}

};

class NonVerifiableTransferTransactionV2 : (NonVerifiableTransaction) {
public:
	TRANSACTION_VERSION: int = 2;
	TRANSACTION_TYPE: TransactionType = TransactionType.TRANSFER;
	TYPE_HINTS = {
		'type_': 'enum:TransactionType',
		'network': 'enum:NetworkType',
		'timestamp': 'pod:Timestamp',
		'signer_public_key': 'pod:PublicKey',
		'fee': 'pod:Amount',
		'deadline': 'pod:Timestamp',
		'recipient_address': 'pod:Address',
		'amount': 'pod:Amount',
		'message': 'struct:Message',
		'mosaics': 'array[SizePrefixedMosaic]'
	}
	;

	void NonVerifiableTransferTransactionV2() {
		self._type_ = NonVerifiableTransferTransactionV2.TRANSACTION_TYPE
		self._version = NonVerifiableTransferTransactionV2.TRANSACTION_VERSION
		self._network = NetworkType.MAINNET
		self._timestamp = Timestamp()
		self._signer_public_key = PublicKey()
		self._fee = Amount()
		self._deadline = Timestamp()
		self._recipient_address = Address()
		self._amount = Amount()
		self._message = None
		self._mosaics = []
		self._entity_body_reserved_1 = 0  # reserved field
		self._signer_public_key_size = 32  # reserved field
		self._recipient_address_size = 40  # reserved field
	}

	void sort() {
		if 0 != self.message_envelope_size_computed:
			self._message.sort()
	}

	TransactionType type_() {
		return self._type_
	}

	int version() {
		return self._version
	}

	NetworkType network() {
		return self._network
	}

	Timestamp timestamp() {
		return self._timestamp
	}

	PublicKey signer_public_key() {
		return self._signer_public_key
	}

	Amount fee() {
		return self._fee
	}

	Timestamp deadline() {
		return self._deadline
	}

	Address recipient_address() {
		return self._recipient_address
	}

	Amount amount() {
		return self._amount
	}

	Message message() {
		return self._message
	}

	List[SizePrefixedMosaic] mosaics() {
		return self._mosaics
	}

	int message_envelope_size_computed() {
		return 0 if not self.message else self.message.size + 0
	}

	void type_(value: TransactionType) {
		self._type_ = value
	}

	void version(value: int) {
		self._version = value
	}

	void network(value: NetworkType) {
		self._network = value
	}

	void timestamp(value: Timestamp) {
		self._timestamp = value
	}

	void signer_public_key(value: PublicKey) {
		self._signer_public_key = value
	}

	void fee(value: Amount) {
		self._fee = value
	}

	void deadline(value: Timestamp) {
		self._deadline = value
	}

	void recipient_address(value: Address) {
		self._recipient_address = value
	}

	void amount(value: Amount) {
		self._amount = value
	}

	void message(value: Message) {
		self._message = value
	}

	void mosaics(value: List[SizePrefixedMosaic]) {
		self._mosaics = value
	}

	size_t size() {
		size = 0
		size += self.type_.size
		size += 1
		size += 2
		size += self.network.size
		size += self.timestamp.size
		size += 4
		size += self.signer_public_key.size
		size += self.fee.size
		size += self.deadline.size
		size += 4
		size += self.recipient_address.size
		size += self.amount.size
		size += 4
		if 0 != self.message_envelope_size_computed:
			size += self.message.size
		size += 4
		size += ArrayHelpers.size(self.mosaics)
		return size
	}

	NonVerifiableTransferTransactionV2 deserialize(const std::vector<uint8_t>& buffer) {
		buffer = memoryview(payload)
		instance = NonVerifiableTransferTransactionV2()
		type_ = TransactionType.deserialize(buffer)
		buffer = buffer[type_.size:]
		version = int.from_bytes(buffer[:1], byteorder='little', signed=False)
		buffer = buffer[1:]
		entity_body_reserved_1 = int.from_bytes(buffer[:2], byteorder='little', signed=False)
		buffer = buffer[2:]
		assert entity_body_reserved_1 == 0, f'Invalid value of reserved field ({entity_body_reserved_1})'
		network = NetworkType.deserialize(buffer)
		buffer = buffer[network.size:]
		timestamp = Timestamp.deserialize(buffer)
		buffer = buffer[timestamp.size:]
		signer_public_key_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert signer_public_key_size == 32, f'Invalid value of reserved field ({signer_public_key_size})'
		signer_public_key = PublicKey.deserialize(buffer)
		buffer = buffer[signer_public_key.size:]
		fee = Amount.deserialize(buffer)
		buffer = buffer[fee.size:]
		deadline = Timestamp.deserialize(buffer)
		buffer = buffer[deadline.size:]
		recipient_address_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		assert recipient_address_size == 40, f'Invalid value of reserved field ({recipient_address_size})'
		recipient_address = Address.deserialize(buffer)
		buffer = buffer[recipient_address.size:]
		amount = Amount.deserialize(buffer)
		buffer = buffer[amount.size:]
		message_envelope_size = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		message = None
		if 0 != message_envelope_size:
			message = Message.deserialize(buffer)
			buffer = buffer[message.size:]
		mosaics_count = int.from_bytes(buffer[:4], byteorder='little', signed=False)
		buffer = buffer[4:]
		mosaics = ArrayHelpers.read_array_count(buffer, SizePrefixedMosaic, mosaics_count)
		buffer = buffer[ArrayHelpers.size(mosaics):]

		# pylint: disable=protected-access
		instance._type_ = type_
		instance._version = version
		instance._network = network
		instance._timestamp = timestamp
		instance._signer_public_key = signer_public_key
		instance._fee = fee
		instance._deadline = deadline
		instance._recipient_address = recipient_address
		instance._amount = amount
		instance._message = message
		instance._mosaics = mosaics
		return instance
	}

	std::vector<uint8_t> serialize() {
		buffer = bytearray()
		buffer += self._type_.serialize()
		buffer += self._version.to_bytes(1, byteorder='little', signed=False)
		buffer += self._entity_body_reserved_1.to_bytes(2, byteorder='little', signed=False)
		buffer += self._network.serialize()
		buffer += self._timestamp.serialize()
		buffer += self._signer_public_key_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._signer_public_key.serialize()
		buffer += self._fee.serialize()
		buffer += self._deadline.serialize()
		buffer += self._recipient_address_size.to_bytes(4, byteorder='little', signed=False)
		buffer += self._recipient_address.serialize()
		buffer += self._amount.serialize()
		buffer += self.message_envelope_size_computed.to_bytes(4, byteorder='little', signed=False)
		if 0 != self.message_envelope_size_computed:
			buffer += self._message.serialize()
		buffer += len(self._mosaics).to_bytes(4, byteorder='little', signed=False)  # mosaics_count
		buffer += ArrayHelpers.write_array(self._mosaics)
		return buffer
	}

	std::string to_string() {
		result = '('
		result += f'type: {self._type_.__str__()}, '
		result += f'version: 0x{self._version:X}, '
		result += f'network: {self._network.__str__()}, '
		result += f'timestamp: {self._timestamp.__str__()}, '
		result += f'signer_public_key: {self._signer_public_key.__str__()}, '
		result += f'fee: {self._fee.__str__()}, '
		result += f'deadline: {self._deadline.__str__()}, '
		result += f'recipient_address: {self._recipient_address.__str__()}, '
		result += f'amount: {self._amount.__str__()}, '
		if 0 != self.message_envelope_size_computed:
			result += f'message: {self._message.__str__()}, '
		result += f'mosaics: {list(map(str, self._mosaics))}, '
		result += ')'
		return result
	}

	std::string to_json() {
		result = {}
		result['type'] = self._type_.to_json()
		result['version'] = self._version
		result['network'] = self._network.to_json()
		result['timestamp'] = self._timestamp.to_json()
		result['signer_public_key'] = self._signer_public_key.to_json()
		result['fee'] = self._fee.to_json()
		result['deadline'] = self._deadline.to_json()
		result['recipient_address'] = self._recipient_address.to_json()
		result['amount'] = self._amount.to_json()
		if 0 != self.message_envelope_size_computed:
			result['message'] = self._message.to_json()
		result['mosaics'] = [e.to_json() for e in self._mosaics]
		return result
	}

};

class TransactionFactory {
public:
	Transaction deserialize(payload: bytes) {
		parent = Transaction()
		buffer = bytes(payload)
		Transaction._deserialize(buffer, parent)  # pylint: disable=protected-access

		mapping = {
			(AccountKeyLinkTransactionV1.TRANSACTION_TYPE, AccountKeyLinkTransactionV1.TRANSACTION_VERSION): AccountKeyLinkTransactionV1,
			(MosaicDefinitionTransactionV1.TRANSACTION_TYPE, MosaicDefinitionTransactionV1.TRANSACTION_VERSION): MosaicDefinitionTransactionV1,
			(MosaicSupplyChangeTransactionV1.TRANSACTION_TYPE, MosaicSupplyChangeTransactionV1.TRANSACTION_VERSION): MosaicSupplyChangeTransactionV1,
			(MultisigAccountModificationTransactionV1.TRANSACTION_TYPE, MultisigAccountModificationTransactionV1.TRANSACTION_VERSION): MultisigAccountModificationTransactionV1,
			(MultisigAccountModificationTransactionV2.TRANSACTION_TYPE, MultisigAccountModificationTransactionV2.TRANSACTION_VERSION): MultisigAccountModificationTransactionV2,
			(CosignatureV1.TRANSACTION_TYPE, CosignatureV1.TRANSACTION_VERSION): CosignatureV1,
			(MultisigTransactionV1.TRANSACTION_TYPE, MultisigTransactionV1.TRANSACTION_VERSION): MultisigTransactionV1,
			(NamespaceRegistrationTransactionV1.TRANSACTION_TYPE, NamespaceRegistrationTransactionV1.TRANSACTION_VERSION): NamespaceRegistrationTransactionV1,
			(TransferTransactionV1.TRANSACTION_TYPE, TransferTransactionV1.TRANSACTION_VERSION): TransferTransactionV1,
			(TransferTransactionV2.TRANSACTION_TYPE, TransferTransactionV2.TRANSACTION_VERSION): TransferTransactionV2
		}
		discriminator = (parent.type_, parent.version)
		factory_class = mapping[discriminator]
		return factory_class.deserialize(buffer)
	}

	Transaction create_by_name(entity_name: str) {
		mapping = {
			'account_key_link_transaction_v1': AccountKeyLinkTransactionV1,
			'mosaic_definition_transaction_v1': MosaicDefinitionTransactionV1,
			'mosaic_supply_change_transaction_v1': MosaicSupplyChangeTransactionV1,
			'multisig_account_modification_transaction_v1': MultisigAccountModificationTransactionV1,
			'multisig_account_modification_transaction_v2': MultisigAccountModificationTransactionV2,
			'cosignature_v1': CosignatureV1,
			'multisig_transaction_v1': MultisigTransactionV1,
			'namespace_registration_transaction_v1': NamespaceRegistrationTransactionV1,
			'transfer_transaction_v1': TransferTransactionV1,
			'transfer_transaction_v2': TransferTransactionV2
		}

		if entity_name not in mapping:
			raise ValueError(f'unknown Transaction type {entity_name}')

		return mapping[entity_name]()
	}

};

class NonVerifiableTransactionFactory {
public:
	NonVerifiableTransaction deserialize(payload: bytes) {
		parent = NonVerifiableTransaction()
		buffer = bytes(payload)
		NonVerifiableTransaction._deserialize(buffer, parent)  # pylint: disable=protected-access

		mapping = {
			(NonVerifiableAccountKeyLinkTransactionV1.TRANSACTION_TYPE, NonVerifiableAccountKeyLinkTransactionV1.TRANSACTION_VERSION): NonVerifiableAccountKeyLinkTransactionV1,
			(NonVerifiableMosaicDefinitionTransactionV1.TRANSACTION_TYPE, NonVerifiableMosaicDefinitionTransactionV1.TRANSACTION_VERSION): NonVerifiableMosaicDefinitionTransactionV1,
			(NonVerifiableMosaicSupplyChangeTransactionV1.TRANSACTION_TYPE, NonVerifiableMosaicSupplyChangeTransactionV1.TRANSACTION_VERSION): NonVerifiableMosaicSupplyChangeTransactionV1,
			(NonVerifiableMultisigAccountModificationTransactionV1.TRANSACTION_TYPE, NonVerifiableMultisigAccountModificationTransactionV1.TRANSACTION_VERSION): NonVerifiableMultisigAccountModificationTransactionV1,
			(NonVerifiableMultisigAccountModificationTransactionV2.TRANSACTION_TYPE, NonVerifiableMultisigAccountModificationTransactionV2.TRANSACTION_VERSION): NonVerifiableMultisigAccountModificationTransactionV2,
			(NonVerifiableCosignatureV1.TRANSACTION_TYPE, NonVerifiableCosignatureV1.TRANSACTION_VERSION): NonVerifiableCosignatureV1,
			(NonVerifiableMultisigTransactionV1.TRANSACTION_TYPE, NonVerifiableMultisigTransactionV1.TRANSACTION_VERSION): NonVerifiableMultisigTransactionV1,
			(NonVerifiableNamespaceRegistrationTransactionV1.TRANSACTION_TYPE, NonVerifiableNamespaceRegistrationTransactionV1.TRANSACTION_VERSION): NonVerifiableNamespaceRegistrationTransactionV1,
			(NonVerifiableTransferTransactionV1.TRANSACTION_TYPE, NonVerifiableTransferTransactionV1.TRANSACTION_VERSION): NonVerifiableTransferTransactionV1,
			(NonVerifiableTransferTransactionV2.TRANSACTION_TYPE, NonVerifiableTransferTransactionV2.TRANSACTION_VERSION): NonVerifiableTransferTransactionV2
		}
		discriminator = (parent.type_, parent.version)
		factory_class = mapping[discriminator]
		return factory_class.deserialize(buffer)
	}

	NonVerifiableTransaction create_by_name(entity_name: str) {
		mapping = {
			'non_verifiable_account_key_link_transaction_v1': NonVerifiableAccountKeyLinkTransactionV1,
			'non_verifiable_mosaic_definition_transaction_v1': NonVerifiableMosaicDefinitionTransactionV1,
			'non_verifiable_mosaic_supply_change_transaction_v1': NonVerifiableMosaicSupplyChangeTransactionV1,
			'non_verifiable_multisig_account_modification_transaction_v1': NonVerifiableMultisigAccountModificationTransactionV1,
			'non_verifiable_multisig_account_modification_transaction_v2': NonVerifiableMultisigAccountModificationTransactionV2,
			'non_verifiable_cosignature_v1': NonVerifiableCosignatureV1,
			'non_verifiable_multisig_transaction_v1': NonVerifiableMultisigTransactionV1,
			'non_verifiable_namespace_registration_transaction_v1': NonVerifiableNamespaceRegistrationTransactionV1,
			'non_verifiable_transfer_transaction_v1': NonVerifiableTransferTransactionV1,
			'non_verifiable_transfer_transaction_v2': NonVerifiableTransferTransactionV2
		}

		if entity_name not in mapping:
			raise ValueError(f'unknown NonVerifiableTransaction type {entity_name}')

		return mapping[entity_name]()
	}

};